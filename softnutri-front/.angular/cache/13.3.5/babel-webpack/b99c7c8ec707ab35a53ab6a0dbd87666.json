{"ast":null,"code":"import Transformable, { TRANSFORMABLE_PROPS } from './core/Transformable.js';\nimport Animator, { cloneValue } from './animation/Animator.js';\nimport BoundingRect from './core/BoundingRect.js';\nimport Eventful from './core/Eventful.js';\nimport { calculateTextPosition, parsePercent } from './contain/text.js';\nimport { guid, isObject, keys, extend, indexOf, logError, mixin, isArrayLike, isTypedArray, isGradientObject, filter, reduce } from './core/util.js';\nimport { LIGHT_LABEL_COLOR, DARK_LABEL_COLOR } from './config.js';\nimport { parse, stringify } from './tool/color.js';\nimport { REDRAW_BIT } from './graphic/constants.js';\nexport var PRESERVED_NORMAL_STATE = '__zr_normal__';\nvar PRIMARY_STATES_KEYS = TRANSFORMABLE_PROPS.concat(['ignore']);\nvar DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function (obj, key) {\n  obj[key] = true;\n  return obj;\n}, {\n  ignore: false\n});\nvar tmpTextPosCalcRes = {};\nvar tmpBoundingRect = new BoundingRect(0, 0, 0, 0);\n\nvar Element = function () {\n  function Element(props) {\n    this.id = guid();\n    this.animators = [];\n    this.currentStates = [];\n    this.states = {};\n\n    this._init(props);\n  }\n\n  Element.prototype._init = function (props) {\n    this.attr(props);\n  };\n\n  Element.prototype.drift = function (dx, dy, e) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.markRedraw();\n  };\n\n  Element.prototype.beforeUpdate = function () {};\n\n  Element.prototype.afterUpdate = function () {};\n\n  Element.prototype.update = function () {\n    this.updateTransform();\n\n    if (this.__dirty) {\n      this.updateInnerText();\n    }\n  };\n\n  Element.prototype.updateInnerText = function (forceUpdate) {\n    var textEl = this._textContent;\n\n    if (textEl && (!textEl.ignore || forceUpdate)) {\n      if (!this.textConfig) {\n        this.textConfig = {};\n      }\n\n      var textConfig = this.textConfig;\n      var isLocal = textConfig.local;\n      var innerTransformable = textEl.innerTransformable;\n      var textAlign = void 0;\n      var textVerticalAlign = void 0;\n      var textStyleChanged = false;\n      innerTransformable.parent = isLocal ? this : null;\n      var innerOrigin = false;\n      innerTransformable.copyTransform(textEl);\n\n      if (textConfig.position != null) {\n        var layoutRect = tmpBoundingRect;\n\n        if (textConfig.layoutRect) {\n          layoutRect.copy(textConfig.layoutRect);\n        } else {\n          layoutRect.copy(this.getBoundingRect());\n        }\n\n        if (!isLocal) {\n          layoutRect.applyTransform(this.transform);\n        }\n\n        if (this.calculateTextPosition) {\n          this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);\n        } else {\n          calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);\n        }\n\n        innerTransformable.x = tmpTextPosCalcRes.x;\n        innerTransformable.y = tmpTextPosCalcRes.y;\n        textAlign = tmpTextPosCalcRes.align;\n        textVerticalAlign = tmpTextPosCalcRes.verticalAlign;\n        var textOrigin = textConfig.origin;\n\n        if (textOrigin && textConfig.rotation != null) {\n          var relOriginX = void 0;\n          var relOriginY = void 0;\n\n          if (textOrigin === 'center') {\n            relOriginX = layoutRect.width * 0.5;\n            relOriginY = layoutRect.height * 0.5;\n          } else {\n            relOriginX = parsePercent(textOrigin[0], layoutRect.width);\n            relOriginY = parsePercent(textOrigin[1], layoutRect.height);\n          }\n\n          innerOrigin = true;\n          innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);\n          innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);\n        }\n      }\n\n      if (textConfig.rotation != null) {\n        innerTransformable.rotation = textConfig.rotation;\n      }\n\n      var textOffset = textConfig.offset;\n\n      if (textOffset) {\n        innerTransformable.x += textOffset[0];\n        innerTransformable.y += textOffset[1];\n\n        if (!innerOrigin) {\n          innerTransformable.originX = -textOffset[0];\n          innerTransformable.originY = -textOffset[1];\n        }\n      }\n\n      var isInside = textConfig.inside == null ? typeof textConfig.position === 'string' && textConfig.position.indexOf('inside') >= 0 : textConfig.inside;\n      var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});\n      var textFill = void 0;\n      var textStroke = void 0;\n      var autoStroke = void 0;\n\n      if (isInside && this.canBeInsideText()) {\n        textFill = textConfig.insideFill;\n        textStroke = textConfig.insideStroke;\n\n        if (textFill == null || textFill === 'auto') {\n          textFill = this.getInsideTextFill();\n        }\n\n        if (textStroke == null || textStroke === 'auto') {\n          textStroke = this.getInsideTextStroke(textFill);\n          autoStroke = true;\n        }\n      } else {\n        textFill = textConfig.outsideFill;\n        textStroke = textConfig.outsideStroke;\n\n        if (textFill == null || textFill === 'auto') {\n          textFill = this.getOutsideFill();\n        }\n\n        if (textStroke == null || textStroke === 'auto') {\n          textStroke = this.getOutsideStroke(textFill);\n          autoStroke = true;\n        }\n      }\n\n      textFill = textFill || '#000';\n\n      if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {\n        textStyleChanged = true;\n        innerTextDefaultStyle.fill = textFill;\n        innerTextDefaultStyle.stroke = textStroke;\n        innerTextDefaultStyle.autoStroke = autoStroke;\n        innerTextDefaultStyle.align = textAlign;\n        innerTextDefaultStyle.verticalAlign = textVerticalAlign;\n        textEl.setDefaultTextStyle(innerTextDefaultStyle);\n      }\n\n      textEl.__dirty |= REDRAW_BIT;\n\n      if (textStyleChanged) {\n        textEl.dirtyStyle(true);\n      }\n    }\n  };\n\n  Element.prototype.canBeInsideText = function () {\n    return true;\n  };\n\n  Element.prototype.getInsideTextFill = function () {\n    return '#fff';\n  };\n\n  Element.prototype.getInsideTextStroke = function (textFill) {\n    return '#000';\n  };\n\n  Element.prototype.getOutsideFill = function () {\n    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;\n  };\n\n  Element.prototype.getOutsideStroke = function (textFill) {\n    var backgroundColor = this.__zr && this.__zr.getBackgroundColor();\n\n    var colorArr = typeof backgroundColor === 'string' && parse(backgroundColor);\n\n    if (!colorArr) {\n      colorArr = [255, 255, 255, 1];\n    }\n\n    var alpha = colorArr[3];\n\n    var isDark = this.__zr.isDarkMode();\n\n    for (var i = 0; i < 3; i++) {\n      colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);\n    }\n\n    colorArr[3] = 1;\n    return stringify(colorArr, 'rgba');\n  };\n\n  Element.prototype.traverse = function (cb, context) {};\n\n  Element.prototype.attrKV = function (key, value) {\n    if (key === 'textConfig') {\n      this.setTextConfig(value);\n    } else if (key === 'textContent') {\n      this.setTextContent(value);\n    } else if (key === 'clipPath') {\n      this.setClipPath(value);\n    } else if (key === 'extra') {\n      this.extra = this.extra || {};\n      extend(this.extra, value);\n    } else {\n      this[key] = value;\n    }\n  };\n\n  Element.prototype.hide = function () {\n    this.ignore = true;\n    this.markRedraw();\n  };\n\n  Element.prototype.show = function () {\n    this.ignore = false;\n    this.markRedraw();\n  };\n\n  Element.prototype.attr = function (keyOrObj, value) {\n    if (typeof keyOrObj === 'string') {\n      this.attrKV(keyOrObj, value);\n    } else if (isObject(keyOrObj)) {\n      var obj = keyOrObj;\n      var keysArr = keys(obj);\n\n      for (var i = 0; i < keysArr.length; i++) {\n        var key = keysArr[i];\n        this.attrKV(key, keyOrObj[key]);\n      }\n    }\n\n    this.markRedraw();\n    return this;\n  };\n\n  Element.prototype.saveCurrentToNormalState = function (toState) {\n    this._innerSaveToNormal(toState);\n\n    var normalState = this._normalState;\n\n    for (var i = 0; i < this.animators.length; i++) {\n      var animator = this.animators[i];\n      var fromStateTransition = animator.__fromStateTransition;\n\n      if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {\n        continue;\n      }\n\n      var targetName = animator.targetName;\n      var target = targetName ? normalState[targetName] : normalState;\n      animator.saveTo(target);\n    }\n  };\n\n  Element.prototype._innerSaveToNormal = function (toState) {\n    var normalState = this._normalState;\n\n    if (!normalState) {\n      normalState = this._normalState = {};\n    }\n\n    if (toState.textConfig && !normalState.textConfig) {\n      normalState.textConfig = this.textConfig;\n    }\n\n    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);\n  };\n\n  Element.prototype._savePrimaryToNormal = function (toState, normalState, primaryKeys) {\n    for (var i = 0; i < primaryKeys.length; i++) {\n      var key = primaryKeys[i];\n\n      if (toState[key] != null && !(key in normalState)) {\n        normalState[key] = this[key];\n      }\n    }\n  };\n\n  Element.prototype.hasState = function () {\n    return this.currentStates.length > 0;\n  };\n\n  Element.prototype.getState = function (name) {\n    return this.states[name];\n  };\n\n  Element.prototype.ensureState = function (name) {\n    var states = this.states;\n\n    if (!states[name]) {\n      states[name] = {};\n    }\n\n    return states[name];\n  };\n\n  Element.prototype.clearStates = function (noAnimation) {\n    this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);\n  };\n\n  Element.prototype.useState = function (stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {\n    var toNormalState = stateName === PRESERVED_NORMAL_STATE;\n    var hasStates = this.hasState();\n\n    if (!hasStates && toNormalState) {\n      return;\n    }\n\n    var currentStates = this.currentStates;\n    var animationCfg = this.stateTransition;\n\n    if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {\n      return;\n    }\n\n    var state;\n\n    if (this.stateProxy && !toNormalState) {\n      state = this.stateProxy(stateName);\n    }\n\n    if (!state) {\n      state = this.states && this.states[stateName];\n    }\n\n    if (!state && !toNormalState) {\n      logError(\"State \" + stateName + \" not exists.\");\n      return;\n    }\n\n    if (!toNormalState) {\n      this.saveCurrentToNormalState(state);\n    }\n\n    var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);\n\n    if (useHoverLayer) {\n      this._toggleHoverLayerFlag(true);\n    }\n\n    this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);\n\n    var textContent = this._textContent;\n    var textGuide = this._textGuide;\n\n    if (textContent) {\n      textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);\n    }\n\n    if (textGuide) {\n      textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);\n    }\n\n    if (toNormalState) {\n      this.currentStates = [];\n      this._normalState = {};\n    } else {\n      if (!keepCurrentStates) {\n        this.currentStates = [stateName];\n      } else {\n        this.currentStates.push(stateName);\n      }\n    }\n\n    this._updateAnimationTargets();\n\n    this.markRedraw();\n\n    if (!useHoverLayer && this.__inHover) {\n      this._toggleHoverLayerFlag(false);\n\n      this.__dirty &= ~REDRAW_BIT;\n    }\n\n    return state;\n  };\n\n  Element.prototype.useStates = function (states, noAnimation, forceUseHoverLayer) {\n    if (!states.length) {\n      this.clearStates();\n    } else {\n      var stateObjects = [];\n      var currentStates = this.currentStates;\n      var len = states.length;\n      var notChange = len === currentStates.length;\n\n      if (notChange) {\n        for (var i = 0; i < len; i++) {\n          if (states[i] !== currentStates[i]) {\n            notChange = false;\n            break;\n          }\n        }\n      }\n\n      if (notChange) {\n        return;\n      }\n\n      for (var i = 0; i < len; i++) {\n        var stateName = states[i];\n        var stateObj = void 0;\n\n        if (this.stateProxy) {\n          stateObj = this.stateProxy(stateName, states);\n        }\n\n        if (!stateObj) {\n          stateObj = this.states[stateName];\n        }\n\n        if (stateObj) {\n          stateObjects.push(stateObj);\n        }\n      }\n\n      var lastStateObj = stateObjects[len - 1];\n      var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);\n\n      if (useHoverLayer) {\n        this._toggleHoverLayerFlag(true);\n      }\n\n      var mergedState = this._mergeStates(stateObjects);\n\n      var animationCfg = this.stateTransition;\n      this.saveCurrentToNormalState(mergedState);\n\n      this._applyStateObj(states.join(','), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);\n\n      var textContent = this._textContent;\n      var textGuide = this._textGuide;\n\n      if (textContent) {\n        textContent.useStates(states, noAnimation, useHoverLayer);\n      }\n\n      if (textGuide) {\n        textGuide.useStates(states, noAnimation, useHoverLayer);\n      }\n\n      this._updateAnimationTargets();\n\n      this.currentStates = states.slice();\n      this.markRedraw();\n\n      if (!useHoverLayer && this.__inHover) {\n        this._toggleHoverLayerFlag(false);\n\n        this.__dirty &= ~REDRAW_BIT;\n      }\n    }\n  };\n\n  Element.prototype._updateAnimationTargets = function () {\n    for (var i = 0; i < this.animators.length; i++) {\n      var animator = this.animators[i];\n\n      if (animator.targetName) {\n        animator.changeTarget(this[animator.targetName]);\n      }\n    }\n  };\n\n  Element.prototype.removeState = function (state) {\n    var idx = indexOf(this.currentStates, state);\n\n    if (idx >= 0) {\n      var currentStates = this.currentStates.slice();\n      currentStates.splice(idx, 1);\n      this.useStates(currentStates);\n    }\n  };\n\n  Element.prototype.replaceState = function (oldState, newState, forceAdd) {\n    var currentStates = this.currentStates.slice();\n    var idx = indexOf(currentStates, oldState);\n    var newStateExists = indexOf(currentStates, newState) >= 0;\n\n    if (idx >= 0) {\n      if (!newStateExists) {\n        currentStates[idx] = newState;\n      } else {\n        currentStates.splice(idx, 1);\n      }\n    } else if (forceAdd && !newStateExists) {\n      currentStates.push(newState);\n    }\n\n    this.useStates(currentStates);\n  };\n\n  Element.prototype.toggleState = function (state, enable) {\n    if (enable) {\n      this.useState(state, true);\n    } else {\n      this.removeState(state);\n    }\n  };\n\n  Element.prototype._mergeStates = function (states) {\n    var mergedState = {};\n    var mergedTextConfig;\n\n    for (var i = 0; i < states.length; i++) {\n      var state = states[i];\n      extend(mergedState, state);\n\n      if (state.textConfig) {\n        mergedTextConfig = mergedTextConfig || {};\n        extend(mergedTextConfig, state.textConfig);\n      }\n    }\n\n    if (mergedTextConfig) {\n      mergedState.textConfig = mergedTextConfig;\n    }\n\n    return mergedState;\n  };\n\n  Element.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {\n    var needsRestoreToNormal = !(state && keepCurrentStates);\n\n    if (state && state.textConfig) {\n      this.textConfig = extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig);\n      extend(this.textConfig, state.textConfig);\n    } else if (needsRestoreToNormal) {\n      if (normalState.textConfig) {\n        this.textConfig = normalState.textConfig;\n      }\n    }\n\n    var transitionTarget = {};\n    var hasTransition = false;\n\n    for (var i = 0; i < PRIMARY_STATES_KEYS.length; i++) {\n      var key = PRIMARY_STATES_KEYS[i];\n      var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];\n\n      if (state && state[key] != null) {\n        if (propNeedsTransition) {\n          hasTransition = true;\n          transitionTarget[key] = state[key];\n        } else {\n          this[key] = state[key];\n        }\n      } else if (needsRestoreToNormal) {\n        if (normalState[key] != null) {\n          if (propNeedsTransition) {\n            hasTransition = true;\n            transitionTarget[key] = normalState[key];\n          } else {\n            this[key] = normalState[key];\n          }\n        }\n      }\n    }\n\n    if (!transition) {\n      for (var i = 0; i < this.animators.length; i++) {\n        var animator = this.animators[i];\n        var targetName = animator.targetName;\n\n        if (!animator.getLoop()) {\n          animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);\n        }\n      }\n    }\n\n    if (hasTransition) {\n      this._transitionState(stateName, transitionTarget, animationCfg);\n    }\n  };\n\n  Element.prototype._attachComponent = function (componentEl) {\n    if (componentEl.__zr && !componentEl.__hostTarget) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error('Text element has been added to zrender.');\n      }\n\n      return;\n    }\n\n    if (componentEl === this) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error('Recursive component attachment.');\n      }\n\n      return;\n    }\n\n    var zr = this.__zr;\n\n    if (zr) {\n      componentEl.addSelfToZr(zr);\n    }\n\n    componentEl.__zr = zr;\n    componentEl.__hostTarget = this;\n  };\n\n  Element.prototype._detachComponent = function (componentEl) {\n    if (componentEl.__zr) {\n      componentEl.removeSelfFromZr(componentEl.__zr);\n    }\n\n    componentEl.__zr = null;\n    componentEl.__hostTarget = null;\n  };\n\n  Element.prototype.getClipPath = function () {\n    return this._clipPath;\n  };\n\n  Element.prototype.setClipPath = function (clipPath) {\n    if (this._clipPath && this._clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this._attachComponent(clipPath);\n\n    this._clipPath = clipPath;\n    this.markRedraw();\n  };\n\n  Element.prototype.removeClipPath = function () {\n    var clipPath = this._clipPath;\n\n    if (clipPath) {\n      this._detachComponent(clipPath);\n\n      this._clipPath = null;\n      this.markRedraw();\n    }\n  };\n\n  Element.prototype.getTextContent = function () {\n    return this._textContent;\n  };\n\n  Element.prototype.setTextContent = function (textEl) {\n    var previousTextContent = this._textContent;\n\n    if (previousTextContent === textEl) {\n      return;\n    }\n\n    if (previousTextContent && previousTextContent !== textEl) {\n      this.removeTextContent();\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (textEl.__zr && !textEl.__hostTarget) {\n        throw new Error('Text element has been added to zrender.');\n      }\n    }\n\n    textEl.innerTransformable = new Transformable();\n\n    this._attachComponent(textEl);\n\n    this._textContent = textEl;\n    this.markRedraw();\n  };\n\n  Element.prototype.setTextConfig = function (cfg) {\n    if (!this.textConfig) {\n      this.textConfig = {};\n    }\n\n    extend(this.textConfig, cfg);\n    this.markRedraw();\n  };\n\n  Element.prototype.removeTextConfig = function () {\n    this.textConfig = null;\n    this.markRedraw();\n  };\n\n  Element.prototype.removeTextContent = function () {\n    var textEl = this._textContent;\n\n    if (textEl) {\n      textEl.innerTransformable = null;\n\n      this._detachComponent(textEl);\n\n      this._textContent = null;\n      this._innerTextDefaultStyle = null;\n      this.markRedraw();\n    }\n  };\n\n  Element.prototype.getTextGuideLine = function () {\n    return this._textGuide;\n  };\n\n  Element.prototype.setTextGuideLine = function (guideLine) {\n    if (this._textGuide && this._textGuide !== guideLine) {\n      this.removeTextGuideLine();\n    }\n\n    this._attachComponent(guideLine);\n\n    this._textGuide = guideLine;\n    this.markRedraw();\n  };\n\n  Element.prototype.removeTextGuideLine = function () {\n    var textGuide = this._textGuide;\n\n    if (textGuide) {\n      this._detachComponent(textGuide);\n\n      this._textGuide = null;\n      this.markRedraw();\n    }\n  };\n\n  Element.prototype.markRedraw = function () {\n    this.__dirty |= REDRAW_BIT;\n    var zr = this.__zr;\n\n    if (zr) {\n      if (this.__inHover) {\n        zr.refreshHover();\n      } else {\n        zr.refresh();\n      }\n    }\n\n    if (this.__hostTarget) {\n      this.__hostTarget.markRedraw();\n    }\n  };\n\n  Element.prototype.dirty = function () {\n    this.markRedraw();\n  };\n\n  Element.prototype._toggleHoverLayerFlag = function (inHover) {\n    this.__inHover = inHover;\n    var textContent = this._textContent;\n    var textGuide = this._textGuide;\n\n    if (textContent) {\n      textContent.__inHover = inHover;\n    }\n\n    if (textGuide) {\n      textGuide.__inHover = inHover;\n    }\n  };\n\n  Element.prototype.addSelfToZr = function (zr) {\n    if (this.__zr === zr) {\n      return;\n    }\n\n    this.__zr = zr;\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this._clipPath) {\n      this._clipPath.addSelfToZr(zr);\n    }\n\n    if (this._textContent) {\n      this._textContent.addSelfToZr(zr);\n    }\n\n    if (this._textGuide) {\n      this._textGuide.addSelfToZr(zr);\n    }\n  };\n\n  Element.prototype.removeSelfFromZr = function (zr) {\n    if (!this.__zr) {\n      return;\n    }\n\n    this.__zr = null;\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this._clipPath) {\n      this._clipPath.removeSelfFromZr(zr);\n    }\n\n    if (this._textContent) {\n      this._textContent.removeSelfFromZr(zr);\n    }\n\n    if (this._textGuide) {\n      this._textGuide.removeSelfFromZr(zr);\n    }\n  };\n\n  Element.prototype.animate = function (key, loop, allowDiscreteAnimation) {\n    var target = key ? this[key] : this;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!target) {\n        logError('Property \"' + key + '\" is not existed in element ' + this.id);\n        return;\n      }\n    }\n\n    var animator = new Animator(target, loop, allowDiscreteAnimation);\n    key && (animator.targetName = key);\n    this.addAnimator(animator, key);\n    return animator;\n  };\n\n  Element.prototype.addAnimator = function (animator, key) {\n    var zr = this.__zr;\n    var el = this;\n    animator.during(function () {\n      el.updateDuringAnimation(key);\n    }).done(function () {\n      var animators = el.animators;\n      var idx = indexOf(animators, animator);\n\n      if (idx >= 0) {\n        animators.splice(idx, 1);\n      }\n    });\n    this.animators.push(animator);\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    zr && zr.wakeUp();\n  };\n\n  Element.prototype.updateDuringAnimation = function (key) {\n    this.markRedraw();\n  };\n\n  Element.prototype.stopAnimation = function (scope, forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n    var leftAnimators = [];\n\n    for (var i = 0; i < len; i++) {\n      var animator = animators[i];\n\n      if (!scope || scope === animator.scope) {\n        animator.stop(forwardToLast);\n      } else {\n        leftAnimators.push(animator);\n      }\n    }\n\n    this.animators = leftAnimators;\n    return this;\n  };\n\n  Element.prototype.animateTo = function (target, cfg, animationProps) {\n    animateTo(this, target, cfg, animationProps);\n  };\n\n  Element.prototype.animateFrom = function (target, cfg, animationProps) {\n    animateTo(this, target, cfg, animationProps, true);\n  };\n\n  Element.prototype._transitionState = function (stateName, target, cfg, animationProps) {\n    var animators = animateTo(this, target, cfg, animationProps);\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].__fromStateTransition = stateName;\n    }\n  };\n\n  Element.prototype.getBoundingRect = function () {\n    return null;\n  };\n\n  Element.prototype.getPaintRect = function () {\n    return null;\n  };\n\n  Element.initDefaultProps = function () {\n    var elProto = Element.prototype;\n    elProto.type = 'element';\n    elProto.name = '';\n    elProto.ignore = elProto.silent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;\n    elProto.__dirty = REDRAW_BIT;\n    var logs = {};\n\n    function logDeprecatedError(key, xKey, yKey) {\n      if (!logs[key + xKey + yKey]) {\n        console.warn(\"DEPRECATED: '\" + key + \"' has been deprecated. use '\" + xKey + \"', '\" + yKey + \"' instead\");\n        logs[key + xKey + yKey] = true;\n      }\n    }\n\n    function createLegacyProperty(key, privateKey, xKey, yKey) {\n      Object.defineProperty(elProto, key, {\n        get: function () {\n          if (process.env.NODE_ENV !== 'production') {\n            logDeprecatedError(key, xKey, yKey);\n          }\n\n          if (!this[privateKey]) {\n            var pos = this[privateKey] = [];\n            enhanceArray(this, pos);\n          }\n\n          return this[privateKey];\n        },\n        set: function (pos) {\n          if (process.env.NODE_ENV !== 'production') {\n            logDeprecatedError(key, xKey, yKey);\n          }\n\n          this[xKey] = pos[0];\n          this[yKey] = pos[1];\n          this[privateKey] = pos;\n          enhanceArray(this, pos);\n        }\n      });\n\n      function enhanceArray(self, pos) {\n        Object.defineProperty(pos, 0, {\n          get: function () {\n            return self[xKey];\n          },\n          set: function (val) {\n            self[xKey] = val;\n          }\n        });\n        Object.defineProperty(pos, 1, {\n          get: function () {\n            return self[yKey];\n          },\n          set: function (val) {\n            self[yKey] = val;\n          }\n        });\n      }\n    }\n\n    if (Object.defineProperty) {\n      createLegacyProperty('position', '_legacyPos', 'x', 'y');\n      createLegacyProperty('scale', '_legacyScale', 'scaleX', 'scaleY');\n      createLegacyProperty('origin', '_legacyOrigin', 'originX', 'originY');\n    }\n  }();\n\n  return Element;\n}();\n\nmixin(Element, Eventful);\nmixin(Element, Transformable);\n\nfunction animateTo(animatable, target, cfg, animationProps, reverse) {\n  cfg = cfg || {};\n  var animators = [];\n  animateToShallow(animatable, '', animatable, target, cfg, animationProps, animators, reverse);\n  var finishCount = animators.length;\n  var doneHappened = false;\n  var cfgDone = cfg.done;\n  var cfgAborted = cfg.aborted;\n\n  var doneCb = function () {\n    doneHappened = true;\n    finishCount--;\n\n    if (finishCount <= 0) {\n      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();\n    }\n  };\n\n  var abortedCb = function () {\n    finishCount--;\n\n    if (finishCount <= 0) {\n      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();\n    }\n  };\n\n  if (!finishCount) {\n    cfgDone && cfgDone();\n  }\n\n  if (animators.length > 0 && cfg.during) {\n    animators[0].during(function (target, percent) {\n      cfg.during(percent);\n    });\n  }\n\n  for (var i = 0; i < animators.length; i++) {\n    var animator = animators[i];\n\n    if (doneCb) {\n      animator.done(doneCb);\n    }\n\n    if (abortedCb) {\n      animator.aborted(abortedCb);\n    }\n\n    if (cfg.force) {\n      animator.duration(cfg.duration);\n    }\n\n    animator.start(cfg.easing);\n  }\n\n  return animators;\n}\n\nfunction copyArrShallow(source, target, len) {\n  for (var i = 0; i < len; i++) {\n    source[i] = target[i];\n  }\n}\n\nfunction is2DArray(value) {\n  return isArrayLike(value[0]);\n}\n\nfunction copyValue(target, source, key) {\n  if (isArrayLike(source[key])) {\n    if (!isArrayLike(target[key])) {\n      target[key] = [];\n    }\n\n    if (isTypedArray(source[key])) {\n      var len = source[key].length;\n\n      if (target[key].length !== len) {\n        target[key] = new source[key].constructor(len);\n        copyArrShallow(target[key], source[key], len);\n      }\n    } else {\n      var sourceArr = source[key];\n      var targetArr = target[key];\n      var len0 = sourceArr.length;\n\n      if (is2DArray(sourceArr)) {\n        var len1 = sourceArr[0].length;\n\n        for (var i = 0; i < len0; i++) {\n          if (!targetArr[i]) {\n            targetArr[i] = Array.prototype.slice.call(sourceArr[i]);\n          } else {\n            copyArrShallow(targetArr[i], sourceArr[i], len1);\n          }\n        }\n      } else {\n        copyArrShallow(targetArr, sourceArr, len0);\n      }\n\n      targetArr.length = sourceArr.length;\n    }\n  } else {\n    target[key] = source[key];\n  }\n}\n\nfunction isValueSame(val1, val2) {\n  return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);\n}\n\nfunction is1DArraySame(arr0, arr1) {\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (arr0[i] !== arr1[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse) {\n  var targetKeys = keys(target);\n  var duration = cfg.duration;\n  var delay = cfg.delay;\n  var additive = cfg.additive;\n  var setToFinal = cfg.setToFinal;\n  var animateAll = !isObject(animationProps);\n  var existsAnimators = animatable.animators;\n  var animationKeys = [];\n\n  for (var k = 0; k < targetKeys.length; k++) {\n    var innerKey = targetKeys[k];\n    var targetVal = target[innerKey];\n\n    if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {\n      if (isObject(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {\n        if (topKey) {\n          if (!reverse) {\n            animateObj[innerKey] = targetVal;\n            animatable.updateDuringAnimation(topKey);\n          }\n\n          continue;\n        }\n\n        animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse);\n      } else {\n        animationKeys.push(innerKey);\n      }\n    } else if (!reverse) {\n      animateObj[innerKey] = targetVal;\n      animatable.updateDuringAnimation(topKey);\n      animationKeys.push(innerKey);\n    }\n  }\n\n  var keyLen = animationKeys.length;\n\n  if (!additive && keyLen) {\n    for (var i = 0; i < existsAnimators.length; i++) {\n      var animator = existsAnimators[i];\n\n      if (animator.targetName === topKey) {\n        var allAborted = animator.stopTracks(animationKeys);\n\n        if (allAborted) {\n          var idx = indexOf(existsAnimators, animator);\n          existsAnimators.splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  if (!cfg.force) {\n    animationKeys = filter(animationKeys, function (key) {\n      return !isValueSame(target[key], animateObj[key]);\n    });\n    keyLen = animationKeys.length;\n  }\n\n  if (keyLen > 0 || cfg.force && !animators.length) {\n    var revertedSource = void 0;\n    var reversedTarget = void 0;\n    var sourceClone = void 0;\n\n    if (reverse) {\n      reversedTarget = {};\n\n      if (setToFinal) {\n        revertedSource = {};\n      }\n\n      for (var i = 0; i < keyLen; i++) {\n        var innerKey = animationKeys[i];\n        reversedTarget[innerKey] = animateObj[innerKey];\n\n        if (setToFinal) {\n          revertedSource[innerKey] = target[innerKey];\n        } else {\n          animateObj[innerKey] = target[innerKey];\n        }\n      }\n    } else if (setToFinal) {\n      sourceClone = {};\n\n      for (var i = 0; i < keyLen; i++) {\n        var innerKey = animationKeys[i];\n        sourceClone[innerKey] = cloneValue(animateObj[innerKey]);\n        copyValue(animateObj, target, innerKey);\n      }\n    }\n\n    var animator = new Animator(animateObj, false, false, additive ? filter(existsAnimators, function (animator) {\n      return animator.targetName === topKey;\n    }) : null);\n    animator.targetName = topKey;\n\n    if (cfg.scope) {\n      animator.scope = cfg.scope;\n    }\n\n    if (setToFinal && revertedSource) {\n      animator.whenWithKeys(0, revertedSource, animationKeys);\n    }\n\n    if (sourceClone) {\n      animator.whenWithKeys(0, sourceClone, animationKeys);\n    }\n\n    animator.whenWithKeys(duration == null ? 500 : duration, reverse ? reversedTarget : target, animationKeys).delay(delay || 0);\n    animatable.addAnimator(animator, topKey);\n    animators.push(animator);\n  }\n}\n\nexport default Element;","map":null,"metadata":{},"sourceType":"module"}