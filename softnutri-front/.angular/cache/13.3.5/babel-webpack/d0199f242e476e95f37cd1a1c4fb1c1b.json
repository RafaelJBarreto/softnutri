{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, Directive, Inject, Input, Output, NgModule } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { of, EMPTY, Subject, asyncScheduler, Observable } from 'rxjs';\nimport { throttleTime, switchMap } from 'rxjs/operators';\n\nclass ChangeFilter {\n  constructor(changes) {\n    this.changes = changes;\n  }\n\n  static of(changes) {\n    return new ChangeFilter(changes);\n  }\n\n  notEmpty(key) {\n    if (this.changes[key]) {\n      const value = this.changes[key].currentValue;\n\n      if (value !== undefined && value !== null) {\n        return of(value);\n      }\n    }\n\n    return EMPTY;\n  }\n\n  has(key) {\n    if (this.changes[key]) {\n      const value = this.changes[key].currentValue;\n      return of(value);\n    }\n\n    return EMPTY;\n  }\n\n  notFirst(key) {\n    if (this.changes[key] && !this.changes[key].isFirstChange()) {\n      const value = this.changes[key].currentValue;\n      return of(value);\n    }\n\n    return EMPTY;\n  }\n\n  notFirstAndEmpty(key) {\n    if (this.changes[key] && !this.changes[key].isFirstChange()) {\n      const value = this.changes[key].currentValue;\n\n      if (value !== undefined && value !== null) {\n        return of(value);\n      }\n    }\n\n    return EMPTY;\n  }\n\n}\n\nconst NGX_ECHARTS_CONFIG = new InjectionToken('NGX_ECHARTS_CONFIG');\nlet NgxEchartsDirective = /*#__PURE__*/(() => {\n  class NgxEchartsDirective {\n    constructor(config, el, ngZone) {\n      this.el = el;\n      this.ngZone = ngZone;\n      this.autoResize = true;\n      this.loadingType = 'default'; // ngx-echarts events\n\n      this.chartInit = new EventEmitter();\n      this.optionsError = new EventEmitter(); // echarts mouse events\n\n      this.chartClick = this.createLazyEvent('click');\n      this.chartDblClick = this.createLazyEvent('dblclick');\n      this.chartMouseDown = this.createLazyEvent('mousedown');\n      this.chartMouseMove = this.createLazyEvent('mousemove');\n      this.chartMouseUp = this.createLazyEvent('mouseup');\n      this.chartMouseOver = this.createLazyEvent('mouseover');\n      this.chartMouseOut = this.createLazyEvent('mouseout');\n      this.chartGlobalOut = this.createLazyEvent('globalout');\n      this.chartContextMenu = this.createLazyEvent('contextmenu'); // echarts mouse events\n\n      this.chartLegendSelectChanged = this.createLazyEvent('legendselectchanged');\n      this.chartLegendSelected = this.createLazyEvent('legendselected');\n      this.chartLegendUnselected = this.createLazyEvent('legendunselected');\n      this.chartLegendScroll = this.createLazyEvent('legendscroll');\n      this.chartDataZoom = this.createLazyEvent('datazoom');\n      this.chartDataRangeSelected = this.createLazyEvent('datarangeselected');\n      this.chartTimelineChanged = this.createLazyEvent('timelinechanged');\n      this.chartTimelinePlayChanged = this.createLazyEvent('timelineplaychanged');\n      this.chartRestore = this.createLazyEvent('restore');\n      this.chartDataViewChanged = this.createLazyEvent('dataviewchanged');\n      this.chartMagicTypeChanged = this.createLazyEvent('magictypechanged');\n      this.chartPieSelectChanged = this.createLazyEvent('pieselectchanged');\n      this.chartPieSelected = this.createLazyEvent('pieselected');\n      this.chartPieUnselected = this.createLazyEvent('pieunselected');\n      this.chartMapSelectChanged = this.createLazyEvent('mapselectchanged');\n      this.chartMapSelected = this.createLazyEvent('mapselected');\n      this.chartMapUnselected = this.createLazyEvent('mapunselected');\n      this.chartAxisAreaSelected = this.createLazyEvent('axisareaselected');\n      this.chartFocusNodeAdjacency = this.createLazyEvent('focusnodeadjacency');\n      this.chartUnfocusNodeAdjacency = this.createLazyEvent('unfocusnodeadjacency');\n      this.chartBrush = this.createLazyEvent('brush');\n      this.chartBrushEnd = this.createLazyEvent('brushend');\n      this.chartBrushSelected = this.createLazyEvent('brushselected');\n      this.chartRendered = this.createLazyEvent('rendered');\n      this.chartFinished = this.createLazyEvent('finished');\n      this.animationFrameID = null;\n      this.resize$ = new Subject();\n      this.echarts = config.echarts;\n    }\n\n    ngOnChanges(changes) {\n      const filter = ChangeFilter.of(changes);\n      filter.notFirstAndEmpty('options').subscribe(opt => this.onOptionsChange(opt));\n      filter.notFirstAndEmpty('merge').subscribe(opt => this.setOption(opt));\n      filter.has('loading').subscribe(v => this.toggleLoading(!!v));\n      filter.notFirst('theme').subscribe(() => this.refreshChart());\n    }\n\n    ngOnInit() {\n      if (!window.ResizeObserver) {\n        throw new Error('please install a polyfill for ResizeObserver');\n      }\n\n      this.resizeSub = this.resize$.pipe(throttleTime(100, asyncScheduler, {\n        leading: false,\n        trailing: true\n      })).subscribe(() => this.resize());\n\n      if (this.autoResize) {\n        this.resizeOb = this.ngZone.runOutsideAngular(() => new window.ResizeObserver(() => {\n          this.animationFrameID = window.requestAnimationFrame(() => this.resize$.next());\n        }));\n        this.resizeOb.observe(this.el.nativeElement);\n      }\n    }\n\n    ngOnDestroy() {\n      window.clearTimeout(this.initChartTimer);\n\n      if (this.resizeSub) {\n        this.resizeSub.unsubscribe();\n      }\n\n      if (this.animationFrameID) {\n        window.cancelAnimationFrame(this.animationFrameID);\n      }\n\n      if (this.resizeOb) {\n        this.resizeOb.unobserve(this.el.nativeElement);\n      }\n\n      this.dispose();\n    }\n\n    ngAfterViewInit() {\n      this.initChartTimer = window.setTimeout(() => this.initChart());\n    }\n\n    dispose() {\n      if (this.chart) {\n        if (!this.chart.isDisposed()) {\n          this.chart.dispose();\n        }\n\n        this.chart = null;\n      }\n    }\n    /**\n     * resize chart\n     */\n\n\n    resize() {\n      if (this.chart) {\n        this.chart.resize();\n      }\n    }\n\n    toggleLoading(loading) {\n      if (this.chart) {\n        loading ? this.chart.showLoading(this.loadingType, this.loadingOpts) : this.chart.hideLoading();\n      }\n    }\n\n    setOption(option, opts) {\n      if (this.chart) {\n        try {\n          this.chart.setOption(option, opts);\n        } catch (e) {\n          console.error(e);\n          this.optionsError.emit(e);\n        }\n      }\n    }\n    /**\n     * dispose old chart and create a new one.\n     */\n\n\n    refreshChart() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.dispose();\n        yield this.initChart();\n      });\n    }\n\n    createChart() {\n      const dom = this.el.nativeElement;\n\n      if (window && window.getComputedStyle) {\n        const prop = window.getComputedStyle(dom, null).getPropertyValue('height');\n\n        if ((!prop || prop === '0px') && (!dom.style.height || dom.style.height === '0px')) {\n          dom.style.height = '400px';\n        }\n      } // here a bit tricky: we check if the echarts module is provided as function returning native import('...') then use the promise\n      // otherwise create the function that imitates behaviour above with a provided as is module\n\n\n      return this.ngZone.runOutsideAngular(() => {\n        const load = typeof this.echarts === 'function' ? this.echarts : () => Promise.resolve(this.echarts);\n        return load().then(({\n          init\n        }) => init(dom, this.theme, this.initOpts));\n      });\n    }\n\n    initChart() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.onOptionsChange(this.options);\n\n        if (this.merge && this.chart) {\n          this.setOption(this.merge);\n        }\n      });\n    }\n\n    onOptionsChange(opt) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!opt) {\n          return;\n        }\n\n        if (this.chart) {\n          this.setOption(this.options, true);\n        } else {\n          this.chart = yield this.createChart();\n          this.chartInit.emit(this.chart);\n          this.setOption(this.options, true);\n        }\n      });\n    } // allows to lazily bind to only those events that are requested through the `@Output` by parent components\n    // see https://stackoverflow.com/questions/51787972/optimal-reentering-the-ngzone-from-eventemitter-event for more info\n\n\n    createLazyEvent(eventName) {\n      return this.chartInit.pipe(switchMap(chart => new Observable(observer => {\n        chart.on(eventName, data => this.ngZone.run(() => observer.next(data)));\n        return () => {\n          if (this.chart) {\n            if (!this.chart.isDisposed()) {\n              chart.off(eventName);\n            }\n          }\n        };\n      })));\n    }\n\n  }\n\n  NgxEchartsDirective.ɵfac = function NgxEchartsDirective_Factory(t) {\n    return new (t || NgxEchartsDirective)(i0.ɵɵdirectiveInject(NGX_ECHARTS_CONFIG), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  NgxEchartsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxEchartsDirective,\n    selectors: [[\"echarts\"], [\"\", \"echarts\", \"\"]],\n    inputs: {\n      options: \"options\",\n      theme: \"theme\",\n      loading: \"loading\",\n      initOpts: \"initOpts\",\n      merge: \"merge\",\n      autoResize: \"autoResize\",\n      loadingType: \"loadingType\",\n      loadingOpts: \"loadingOpts\"\n    },\n    outputs: {\n      chartInit: \"chartInit\",\n      optionsError: \"optionsError\",\n      chartClick: \"chartClick\",\n      chartDblClick: \"chartDblClick\",\n      chartMouseDown: \"chartMouseDown\",\n      chartMouseMove: \"chartMouseMove\",\n      chartMouseUp: \"chartMouseUp\",\n      chartMouseOver: \"chartMouseOver\",\n      chartMouseOut: \"chartMouseOut\",\n      chartGlobalOut: \"chartGlobalOut\",\n      chartContextMenu: \"chartContextMenu\",\n      chartLegendSelectChanged: \"chartLegendSelectChanged\",\n      chartLegendSelected: \"chartLegendSelected\",\n      chartLegendUnselected: \"chartLegendUnselected\",\n      chartLegendScroll: \"chartLegendScroll\",\n      chartDataZoom: \"chartDataZoom\",\n      chartDataRangeSelected: \"chartDataRangeSelected\",\n      chartTimelineChanged: \"chartTimelineChanged\",\n      chartTimelinePlayChanged: \"chartTimelinePlayChanged\",\n      chartRestore: \"chartRestore\",\n      chartDataViewChanged: \"chartDataViewChanged\",\n      chartMagicTypeChanged: \"chartMagicTypeChanged\",\n      chartPieSelectChanged: \"chartPieSelectChanged\",\n      chartPieSelected: \"chartPieSelected\",\n      chartPieUnselected: \"chartPieUnselected\",\n      chartMapSelectChanged: \"chartMapSelectChanged\",\n      chartMapSelected: \"chartMapSelected\",\n      chartMapUnselected: \"chartMapUnselected\",\n      chartAxisAreaSelected: \"chartAxisAreaSelected\",\n      chartFocusNodeAdjacency: \"chartFocusNodeAdjacency\",\n      chartUnfocusNodeAdjacency: \"chartUnfocusNodeAdjacency\",\n      chartBrush: \"chartBrush\",\n      chartBrushEnd: \"chartBrushEnd\",\n      chartBrushSelected: \"chartBrushSelected\",\n      chartRendered: \"chartRendered\",\n      chartFinished: \"chartFinished\"\n    },\n    exportAs: [\"echarts\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return NgxEchartsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxEchartsModule = /*#__PURE__*/(() => {\n  class NgxEchartsModule {\n    static forRoot(config) {\n      return {\n        ngModule: NgxEchartsModule,\n        providers: [{\n          provide: NGX_ECHARTS_CONFIG,\n          useValue: config\n        }]\n      };\n    }\n\n    static forChild() {\n      return {\n        ngModule: NgxEchartsModule\n      };\n    }\n\n  }\n\n  NgxEchartsModule.ɵfac = function NgxEchartsModule_Factory(t) {\n    return new (t || NgxEchartsModule)();\n  };\n\n  NgxEchartsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxEchartsModule\n  });\n  NgxEchartsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[]]\n  });\n  return NgxEchartsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ngx-echarts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NGX_ECHARTS_CONFIG, NgxEchartsDirective, NgxEchartsModule }; //# sourceMappingURL=ngx-echarts.mjs.map","map":null,"metadata":{},"sourceType":"module"}