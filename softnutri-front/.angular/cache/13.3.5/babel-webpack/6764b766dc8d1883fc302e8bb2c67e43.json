{"ast":null,"code":"import { brush, setClipPath } from './graphic.js';\nimport { createElement, createVNode, vNodeToString, getCssString, createBrushScope, createSVGVNode } from './core.js';\nimport { normalizeColor, encodeBase64 } from './helper.js';\nimport { extend, keys, logError, map, retrieve2 } from '../core/util.js';\nimport patch, { updateAttrs } from './patch.js';\nimport { getSize } from '../canvas/helper.js';\nvar svgId = 0;\n\nvar SVGPainter = function () {\n  function SVGPainter(root, storage, opts) {\n    this.type = 'svg';\n    this.refreshHover = createMethodNotSupport('refreshHover');\n    this.configLayer = createMethodNotSupport('configLayer');\n    this.storage = storage;\n    this._opts = opts = extend({}, opts);\n    this.root = root;\n    this._id = 'zr' + svgId++;\n    this._oldVNode = createSVGVNode(opts.width, opts.height);\n\n    if (root && !opts.ssr) {\n      var viewport = this._viewport = document.createElement('div');\n      viewport.style.cssText = 'position:relative;overflow:hidden';\n      var svgDom = this._svgDom = this._oldVNode.elm = createElement('svg');\n      updateAttrs(null, this._oldVNode);\n      viewport.appendChild(svgDom);\n      root.appendChild(viewport);\n    }\n\n    this.resize(opts.width, opts.height);\n  }\n\n  SVGPainter.prototype.getType = function () {\n    return this.type;\n  };\n\n  SVGPainter.prototype.getViewportRoot = function () {\n    return this._viewport;\n  };\n\n  SVGPainter.prototype.getViewportRootOffset = function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  };\n\n  SVGPainter.prototype.getSvgDom = function () {\n    return this._svgDom;\n  };\n\n  SVGPainter.prototype.refresh = function () {\n    if (this.root) {\n      var vnode = this.renderToVNode({\n        willUpdate: true\n      });\n      vnode.attrs.style = 'position:absolute;left:0;top:0;user-select:none';\n      patch(this._oldVNode, vnode);\n      this._oldVNode = vnode;\n    }\n  };\n\n  SVGPainter.prototype.renderOneToVNode = function (el) {\n    return brush(el, createBrushScope(this._id));\n  };\n\n  SVGPainter.prototype.renderToVNode = function (opts) {\n    opts = opts || {};\n    var list = this.storage.getDisplayList(true);\n    var bgColor = this._backgroundColor;\n    var width = this._width;\n    var height = this._height;\n    var scope = createBrushScope(this._id);\n    scope.animation = opts.animation;\n    scope.willUpdate = opts.willUpdate;\n    scope.compress = opts.compress;\n    var children = [];\n\n    if (bgColor && bgColor !== 'none') {\n      var _a = normalizeColor(bgColor),\n          color = _a.color,\n          opacity = _a.opacity;\n\n      this._bgVNode = createVNode('rect', 'bg', {\n        width: width,\n        height: height,\n        x: '0',\n        y: '0',\n        id: '0',\n        fill: color,\n        'fill-opacity': opacity\n      });\n      children.push(this._bgVNode);\n    } else {\n      this._bgVNode = null;\n    }\n\n    var mainVNode = !opts.compress ? this._mainVNode = createVNode('g', 'main', {}, []) : null;\n\n    this._paintList(list, scope, mainVNode ? mainVNode.children : children);\n\n    mainVNode && children.push(mainVNode);\n    var defs = map(keys(scope.defs), function (id) {\n      return scope.defs[id];\n    });\n\n    if (defs.length) {\n      children.push(createVNode('defs', 'defs', {}, defs));\n    }\n\n    if (opts.animation) {\n      var animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, {\n        newline: true\n      });\n\n      if (animationCssStr) {\n        var styleNode = createVNode('style', 'stl', {}, [], animationCssStr);\n        children.push(styleNode);\n      }\n    }\n\n    return createSVGVNode(width, height, children, opts.useViewBox);\n  };\n\n  SVGPainter.prototype.renderToString = function (opts) {\n    opts = opts || {};\n    return vNodeToString(this.renderToVNode({\n      animation: retrieve2(opts.cssAnimation, true),\n      willUpdate: false,\n      compress: true,\n      useViewBox: retrieve2(opts.useViewBox, true)\n    }), {\n      newline: true\n    });\n  };\n\n  SVGPainter.prototype.setBackgroundColor = function (backgroundColor) {\n    this._backgroundColor = backgroundColor;\n    var bgVNode = this._bgVNode;\n\n    if (bgVNode && bgVNode.elm) {\n      var _a = normalizeColor(backgroundColor),\n          color = _a.color,\n          opacity = _a.opacity;\n\n      bgVNode.elm.setAttribute('fill', color);\n\n      if (opacity < 1) {\n        bgVNode.elm.setAttribute('fill-opacity', opacity);\n      }\n    }\n  };\n\n  SVGPainter.prototype.getSvgRoot = function () {\n    return this._mainVNode && this._mainVNode.elm;\n  };\n\n  SVGPainter.prototype._paintList = function (list, scope, out) {\n    var listLen = list.length;\n    var clipPathsGroupsStack = [];\n    var clipPathsGroupsStackDepth = 0;\n    var currentClipPathGroup;\n    var prevClipPaths;\n    var clipGroupNodeIdx = 0;\n\n    for (var i = 0; i < listLen; i++) {\n      var displayable = list[i];\n\n      if (!displayable.invisible) {\n        var clipPaths = displayable.__clipPaths;\n        var len = clipPaths && clipPaths.length || 0;\n        var prevLen = prevClipPaths && prevClipPaths.length || 0;\n        var lca = void 0;\n\n        for (lca = Math.max(len - 1, prevLen - 1); lca >= 0; lca--) {\n          if (clipPaths && prevClipPaths && clipPaths[lca] === prevClipPaths[lca]) {\n            break;\n          }\n        }\n\n        for (var i_1 = prevLen - 1; i_1 > lca; i_1--) {\n          clipPathsGroupsStackDepth--;\n          currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1];\n        }\n\n        for (var i_2 = lca + 1; i_2 < len; i_2++) {\n          var groupAttrs = {};\n          setClipPath(clipPaths[i_2], groupAttrs, scope);\n          var g = createVNode('g', 'clip-g-' + clipGroupNodeIdx++, groupAttrs, []);\n          (currentClipPathGroup ? currentClipPathGroup.children : out).push(g);\n          clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g;\n          currentClipPathGroup = g;\n        }\n\n        prevClipPaths = clipPaths;\n        var ret = brush(displayable, scope);\n\n        if (ret) {\n          (currentClipPathGroup ? currentClipPathGroup.children : out).push(ret);\n        }\n      }\n    }\n  };\n\n  SVGPainter.prototype.resize = function (width, height) {\n    var opts = this._opts;\n    var root = this.root;\n    var viewport = this._viewport;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n\n    if (root && viewport) {\n      viewport.style.display = 'none';\n      width = getSize(root, 0, opts);\n      height = getSize(root, 1, opts);\n      viewport.style.display = '';\n    }\n\n    if (this._width !== width || this._height !== height) {\n      this._width = width;\n      this._height = height;\n\n      if (viewport) {\n        var viewportStyle = viewport.style;\n        viewportStyle.width = width + 'px';\n        viewportStyle.height = height + 'px';\n      }\n\n      var svgDom = this._svgDom;\n\n      if (svgDom) {\n        svgDom.setAttribute('width', width);\n        svgDom.setAttribute('height', height);\n      }\n    }\n  };\n\n  SVGPainter.prototype.getWidth = function () {\n    return this._width;\n  };\n\n  SVGPainter.prototype.getHeight = function () {\n    return this._height;\n  };\n\n  SVGPainter.prototype.dispose = function () {\n    if (this.root) {\n      this.root.innerHTML = '';\n    }\n\n    this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;\n  };\n\n  SVGPainter.prototype.clear = function () {\n    if (this._svgDom) {\n      this._svgDom.innerHTML = null;\n    }\n\n    this._oldVNode = null;\n  };\n\n  SVGPainter.prototype.toDataURL = function (base64) {\n    var str = encodeURIComponent(this.renderToString());\n    var prefix = 'data:image/svg+xml;';\n\n    if (base64) {\n      str = encodeBase64(str);\n      return str && prefix + 'base64,' + str;\n    }\n\n    return prefix + 'charset=UTF-8,' + str;\n  };\n\n  return SVGPainter;\n}();\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    if (process.env.NODE_ENV !== 'production') {\n      logError('In SVG mode painter not support method \"' + method + '\"');\n    }\n  };\n}\n\nexport default SVGPainter;","map":null,"metadata":{},"sourceType":"module"}