{"ast":null,"code":"import { isArray, isObject } from '../core/util.js';\nimport { createElement, createVNode, XMLNS, XML_NAMESPACE, XLINKNS } from './core.js';\nimport * as api from './domapi.js';\nvar colonChar = 58;\nvar xChar = 120;\nvar emptyNode = createVNode('', '');\n\nfunction isUndef(s) {\n  return s === undefined;\n}\n\nfunction isDef(s) {\n  return s !== undefined;\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var map = {};\n\n  for (var i = beginIdx; i <= endIdx; ++i) {\n    var key = children[i].key;\n\n    if (key !== undefined) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (map[key] != null) {\n          console.error(\"Duplicate key \" + key);\n        }\n      }\n\n      map[key] = i;\n    }\n  }\n\n  return map;\n}\n\nfunction sameVnode(vnode1, vnode2) {\n  var isSameKey = vnode1.key === vnode2.key;\n  var isSameTag = vnode1.tag === vnode2.tag;\n  return isSameTag && isSameKey;\n}\n\nfunction createElm(vnode) {\n  var i;\n  var children = vnode.children;\n  var tag = vnode.tag;\n\n  if (isDef(tag)) {\n    var elm = vnode.elm = createElement(tag);\n    updateAttrs(emptyNode, vnode);\n\n    if (isArray(children)) {\n      for (i = 0; i < children.length; ++i) {\n        var ch = children[i];\n\n        if (ch != null) {\n          api.appendChild(elm, createElm(ch));\n        }\n      }\n    } else if (isDef(vnode.text) && !isObject(vnode.text)) {\n      api.appendChild(elm, api.createTextNode(vnode.text));\n    }\n  } else {\n    vnode.elm = api.createTextNode(vnode.text);\n  }\n\n  return vnode.elm;\n}\n\nfunction addVnodes(parentElm, before, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    var ch = vnodes[startIdx];\n\n    if (ch != null) {\n      api.insertBefore(parentElm, createElm(ch), before);\n    }\n  }\n}\n\nfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    var ch = vnodes[startIdx];\n\n    if (ch != null) {\n      if (isDef(ch.tag)) {\n        var parent_1 = api.parentNode(ch.elm);\n        api.removeChild(parent_1, ch.elm);\n      } else {\n        api.removeChild(parentElm, ch.elm);\n      }\n    }\n  }\n}\n\nexport function updateAttrs(oldVnode, vnode) {\n  var key;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode && oldVnode.attrs || {};\n  var attrs = vnode.attrs || {};\n\n  if (oldAttrs === attrs) {\n    return;\n  }\n\n  for (key in attrs) {\n    var cur = attrs[key];\n    var old = oldAttrs[key];\n\n    if (old !== cur) {\n      if (cur === true) {\n        elm.setAttribute(key, '');\n      } else if (cur === false) {\n        elm.removeAttribute(key);\n      } else {\n        if (key.charCodeAt(0) !== xChar) {\n          elm.setAttribute(key, cur);\n        } else if (key === 'xmlns:xlink' || key === 'xmlns') {\n          elm.setAttributeNS(XMLNS, key, cur);\n        } else if (key.charCodeAt(3) === colonChar) {\n          elm.setAttributeNS(XML_NAMESPACE, key, cur);\n        } else if (key.charCodeAt(5) === colonChar) {\n          elm.setAttributeNS(XLINKNS, key, cur);\n        } else {\n          elm.setAttribute(key, cur);\n        }\n      }\n    }\n  }\n\n  for (key in oldAttrs) {\n    if (!(key in attrs)) {\n      elm.removeAttribute(key);\n    }\n  }\n}\n\nfunction updateChildren(parentElm, oldCh, newCh) {\n  var oldStartIdx = 0;\n  var newStartIdx = 0;\n  var oldEndIdx = oldCh.length - 1;\n  var oldStartVnode = oldCh[0];\n  var oldEndVnode = oldCh[oldEndIdx];\n  var newEndIdx = newCh.length - 1;\n  var newStartVnode = newCh[0];\n  var newEndVnode = newCh[newEndIdx];\n  var oldKeyToIdx;\n  var idxInOld;\n  var elmToMove;\n  var before;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldStartVnode, newEndVnode)) {\n      patchVnode(oldStartVnode, newEndVnode);\n      api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldEndVnode, newStartVnode)) {\n      patchVnode(oldEndVnode, newStartVnode);\n      api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      if (isUndef(oldKeyToIdx)) {\n        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n      }\n\n      idxInOld = oldKeyToIdx[newStartVnode.key];\n\n      if (isUndef(idxInOld)) {\n        api.insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);\n      } else {\n        elmToMove = oldCh[idxInOld];\n\n        if (elmToMove.tag !== newStartVnode.tag) {\n          api.insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);\n        } else {\n          patchVnode(elmToMove, newStartVnode);\n          oldCh[idxInOld] = undefined;\n          api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n        }\n      }\n\n      newStartVnode = newCh[++newStartIdx];\n    }\n  }\n\n  if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n    if (oldStartIdx > oldEndIdx) {\n      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);\n    } else {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n}\n\nfunction patchVnode(oldVnode, vnode) {\n  var elm = vnode.elm = oldVnode.elm;\n  var oldCh = oldVnode.children;\n  var ch = vnode.children;\n\n  if (oldVnode === vnode) {\n    return;\n  }\n\n  updateAttrs(oldVnode, vnode);\n\n  if (isUndef(vnode.text)) {\n    if (isDef(oldCh) && isDef(ch)) {\n      if (oldCh !== ch) {\n        updateChildren(elm, oldCh, ch);\n      }\n    } else if (isDef(ch)) {\n      if (isDef(oldVnode.text)) {\n        api.setTextContent(elm, '');\n      }\n\n      addVnodes(elm, null, ch, 0, ch.length - 1);\n    } else if (isDef(oldCh)) {\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n    } else if (isDef(oldVnode.text)) {\n      api.setTextContent(elm, '');\n    }\n  } else if (oldVnode.text !== vnode.text) {\n    if (isDef(oldCh)) {\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n    }\n\n    api.setTextContent(elm, vnode.text);\n  }\n}\n\nexport default function patch(oldVnode, vnode) {\n  if (sameVnode(oldVnode, vnode)) {\n    patchVnode(oldVnode, vnode);\n  } else {\n    var elm = oldVnode.elm;\n    var parent_2 = api.parentNode(elm);\n    createElm(vnode);\n\n    if (parent_2 !== null) {\n      api.insertBefore(parent_2, vnode.elm, api.nextSibling(elm));\n      removeVnodes(parent_2, [oldVnode], 0, 0);\n    }\n  }\n\n  return vnode;\n}","map":null,"metadata":{},"sourceType":"module"}