{"ast":null,"code":"import { isArray } from '../../core/util.js';\nvar PI = Math.PI;\nvar PI2 = PI * 2;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar mathACos = Math.acos;\nvar mathATan2 = Math.atan2;\nvar mathAbs = Math.abs;\nvar mathSqrt = Math.sqrt;\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar e = 1e-4;\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var dx10 = x1 - x0;\n  var dy10 = y1 - y0;\n  var dx32 = x3 - x2;\n  var dy32 = y3 - y2;\n  var t = dy32 * dx10 - dx32 * dy10;\n\n  if (t * t < e) {\n    return;\n  }\n\n  t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;\n  return [x0 + t * dx10, y0 + t * dy10];\n}\n\nfunction computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {\n  var x01 = x0 - x1;\n  var y01 = y0 - y1;\n  var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);\n  var ox = lo * y01;\n  var oy = -lo * x01;\n  var x11 = x0 + ox;\n  var y11 = y0 + oy;\n  var x10 = x1 + ox;\n  var y10 = y1 + oy;\n  var x00 = (x11 + x10) / 2;\n  var y00 = (y11 + y10) / 2;\n  var dx = x10 - x11;\n  var dy = y10 - y11;\n  var d2 = dx * dx + dy * dy;\n  var r = radius - cr;\n  var s = x11 * y10 - x10 * y11;\n  var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax(0, r * r * d2 - s * s));\n  var cx0 = (s * dy - dx * d) / d2;\n  var cy0 = (-s * dx - dy * d) / d2;\n  var cx1 = (s * dy + dx * d) / d2;\n  var cy1 = (-s * dx + dy * d) / d2;\n  var dx0 = cx0 - x00;\n  var dy0 = cy0 - y00;\n  var dx1 = cx1 - x00;\n  var dy1 = cy1 - y00;\n\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {\n    cx0 = cx1;\n    cy0 = cy1;\n  }\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x0: -ox,\n    y0: -oy,\n    x1: cx0 * (radius / r - 1),\n    y1: cy0 * (radius / r - 1)\n  };\n}\n\nfunction normalizeCornerRadius(cr) {\n  var arr;\n\n  if (isArray(cr)) {\n    var len = cr.length;\n\n    if (!len) {\n      return cr;\n    }\n\n    if (len === 1) {\n      arr = [cr[0], cr[0], 0, 0];\n    } else if (len === 2) {\n      arr = [cr[0], cr[0], cr[1], cr[1]];\n    } else if (len === 3) {\n      arr = cr.concat(cr[2]);\n    } else {\n      arr = cr;\n    }\n  } else {\n    arr = [cr, cr, cr, cr];\n  }\n\n  return arr;\n}\n\nexport function buildPath(ctx, shape) {\n  var _a;\n\n  var radius = mathMax(shape.r, 0);\n  var innerRadius = mathMax(shape.r0 || 0, 0);\n  var hasRadius = radius > 0;\n  var hasInnerRadius = innerRadius > 0;\n\n  if (!hasRadius && !hasInnerRadius) {\n    return;\n  }\n\n  if (!hasRadius) {\n    radius = innerRadius;\n    innerRadius = 0;\n  }\n\n  if (innerRadius > radius) {\n    var tmp = radius;\n    radius = innerRadius;\n    innerRadius = tmp;\n  }\n\n  var startAngle = shape.startAngle,\n      endAngle = shape.endAngle;\n\n  if (isNaN(startAngle) || isNaN(endAngle)) {\n    return;\n  }\n\n  var cx = shape.cx,\n      cy = shape.cy;\n  var clockwise = !!shape.clockwise;\n  var arc = mathAbs(endAngle - startAngle);\n  var mod = arc > PI2 && arc % PI2;\n  mod > e && (arc = mod);\n\n  if (!(radius > e)) {\n    ctx.moveTo(cx, cy);\n  } else if (arc > PI2 - e) {\n    ctx.moveTo(cx + radius * mathCos(startAngle), cy + radius * mathSin(startAngle));\n    ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);\n\n    if (innerRadius > e) {\n      ctx.moveTo(cx + innerRadius * mathCos(endAngle), cy + innerRadius * mathSin(endAngle));\n      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);\n    }\n  } else {\n    var icrStart = void 0;\n    var icrEnd = void 0;\n    var ocrStart = void 0;\n    var ocrEnd = void 0;\n    var ocrs = void 0;\n    var ocre = void 0;\n    var icrs = void 0;\n    var icre = void 0;\n    var ocrMax = void 0;\n    var icrMax = void 0;\n    var limitedOcrMax = void 0;\n    var limitedIcrMax = void 0;\n    var xre = void 0;\n    var yre = void 0;\n    var xirs = void 0;\n    var yirs = void 0;\n    var xrs = radius * mathCos(startAngle);\n    var yrs = radius * mathSin(startAngle);\n    var xire = innerRadius * mathCos(endAngle);\n    var yire = innerRadius * mathSin(endAngle);\n    var hasArc = arc > e;\n\n    if (hasArc) {\n      var cornerRadius = shape.cornerRadius;\n\n      if (cornerRadius) {\n        _a = normalizeCornerRadius(cornerRadius), icrStart = _a[0], icrEnd = _a[1], ocrStart = _a[2], ocrEnd = _a[3];\n      }\n\n      var halfRd = mathAbs(radius - innerRadius) / 2;\n      ocrs = mathMin(halfRd, ocrStart);\n      ocre = mathMin(halfRd, ocrEnd);\n      icrs = mathMin(halfRd, icrStart);\n      icre = mathMin(halfRd, icrEnd);\n      limitedOcrMax = ocrMax = mathMax(ocrs, ocre);\n      limitedIcrMax = icrMax = mathMax(icrs, icre);\n\n      if (ocrMax > e || icrMax > e) {\n        xre = radius * mathCos(endAngle);\n        yre = radius * mathSin(endAngle);\n        xirs = innerRadius * mathCos(startAngle);\n        yirs = innerRadius * mathSin(startAngle);\n\n        if (arc < PI) {\n          var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);\n\n          if (it_1) {\n            var x0 = xrs - it_1[0];\n            var y0 = yrs - it_1[1];\n            var x1 = xre - it_1[0];\n            var y1 = yre - it_1[1];\n            var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);\n            var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);\n            limitedOcrMax = mathMin(ocrMax, (radius - b) / (a + 1));\n            limitedIcrMax = mathMin(icrMax, (innerRadius - b) / (a - 1));\n          }\n        }\n      }\n    }\n\n    if (!hasArc) {\n      ctx.moveTo(cx + xrs, cy + yrs);\n    } else if (limitedOcrMax > e) {\n      var crStart = mathMin(ocrStart, limitedOcrMax);\n      var crEnd = mathMin(ocrEnd, limitedOcrMax);\n      var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);\n      var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);\n      ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);\n\n      if (limitedOcrMax < ocrMax && crStart === crEnd) {\n        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);\n      } else {\n        crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);\n        ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);\n        crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);\n      }\n    } else {\n      ctx.moveTo(cx + xrs, cy + yrs);\n      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);\n    }\n\n    if (!(innerRadius > e) || !hasArc) {\n      ctx.lineTo(cx + xire, cy + yire);\n    } else if (limitedIcrMax > e) {\n      var crStart = mathMin(icrStart, limitedIcrMax);\n      var crEnd = mathMin(icrEnd, limitedIcrMax);\n      var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);\n      var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);\n      ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);\n\n      if (limitedIcrMax < icrMax && crStart === crEnd) {\n        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);\n      } else {\n        crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);\n        ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);\n        crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);\n      }\n    } else {\n      ctx.lineTo(cx + xire, cy + yire);\n      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);\n    }\n  }\n\n  ctx.closePath();\n}","map":null,"metadata":{},"sourceType":"module"}