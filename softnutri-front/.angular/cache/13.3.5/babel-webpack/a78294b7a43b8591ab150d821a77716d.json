{"ast":null,"code":"import { cubicSubdivide } from '../core/curve.js';\nimport PathProxy from '../core/PathProxy.js';\nvar CMD = PathProxy.CMD;\n\nfunction aroundEqual(a, b) {\n  return Math.abs(a - b) < 1e-5;\n}\n\nexport function pathToBezierCurves(path) {\n  var data = path.data;\n  var len = path.len();\n  var bezierArrayGroups = [];\n  var currentSubpath;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  function createNewSubpath(x, y) {\n    if (currentSubpath && currentSubpath.length > 2) {\n      bezierArrayGroups.push(currentSubpath);\n    }\n\n    currentSubpath = [x, y];\n  }\n\n  function addLine(x0, y0, x1, y1) {\n    if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n      currentSubpath.push(x0, y0, x1, y1, x1, y1);\n    }\n  }\n\n  function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n    var delta = Math.abs(endAngle - startAngle);\n    var len = Math.tan(delta / 4) * 4 / 3;\n    var dir = endAngle < startAngle ? -1 : 1;\n    var c1 = Math.cos(startAngle);\n    var s1 = Math.sin(startAngle);\n    var c2 = Math.cos(endAngle);\n    var s2 = Math.sin(endAngle);\n    var x1 = c1 * rx + cx;\n    var y1 = s1 * ry + cy;\n    var x4 = c2 * rx + cx;\n    var y4 = s2 * ry + cy;\n    var hx = rx * len * dir;\n    var hy = ry * len * dir;\n    currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n  }\n\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n\n  for (var i = 0; i < len;) {\n    var cmd = data[i++];\n    var isFirst = i === 1;\n\n    if (isFirst) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n\n      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n        currentSubpath = [x0, y0];\n      }\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        xi = x0 = data[i++];\n        yi = y0 = data[i++];\n        createNewSubpath(x0, y0);\n        break;\n\n      case CMD.L:\n        x1 = data[i++];\n        y1 = data[i++];\n        addLine(xi, yi, x1, y1);\n        xi = x1;\n        yi = y1;\n        break;\n\n      case CMD.C:\n        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n        break;\n\n      case CMD.Q:\n        x1 = data[i++];\n        y1 = data[i++];\n        x2 = data[i++];\n        y2 = data[i++];\n        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n        xi = x2;\n        yi = y2;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var startAngle = data[i++];\n        var endAngle = data[i++] + startAngle;\n        i += 1;\n        var anticlockwise = !data[i++];\n        x1 = Math.cos(startAngle) * rx + cx;\n        y1 = Math.sin(startAngle) * ry + cy;\n\n        if (isFirst) {\n          x0 = x1;\n          y0 = y1;\n          createNewSubpath(x0, y0);\n        } else {\n          addLine(xi, yi, x1, y1);\n        }\n\n        xi = Math.cos(endAngle) * rx + cx;\n        yi = Math.sin(endAngle) * ry + cy;\n        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n\n        for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n          var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);\n          addArc(angle, nextAngle, cx, cy, rx, ry);\n        }\n\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        x1 = x0 + data[i++];\n        y1 = y0 + data[i++];\n        createNewSubpath(x1, y0);\n        addLine(x1, y0, x1, y1);\n        addLine(x1, y1, x0, y1);\n        addLine(x0, y1, x0, y0);\n        addLine(x0, y0, x1, y0);\n        break;\n\n      case CMD.Z:\n        currentSubpath && addLine(xi, yi, x0, y0);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (currentSubpath && currentSubpath.length > 2) {\n    bezierArrayGroups.push(currentSubpath);\n  }\n\n  return bezierArrayGroups;\n}\n\nfunction adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out, scale) {\n  if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {\n    out.push(x3, y3);\n    return;\n  }\n\n  var PIXEL_DISTANCE = 2 / scale;\n  var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;\n  var dx = x3 - x0;\n  var dy = y3 - y0;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  dx /= d;\n  dy /= d;\n  var dx1 = x1 - x0;\n  var dy1 = y1 - y0;\n  var dx2 = x2 - x3;\n  var dy2 = y2 - y3;\n  var cp1LenSqr = dx1 * dx1 + dy1 * dy1;\n  var cp2LenSqr = dx2 * dx2 + dy2 * dy2;\n\n  if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {\n    out.push(x3, y3);\n    return;\n  }\n\n  var projLen1 = dx * dx1 + dy * dy1;\n  var projLen2 = -dx * dx2 - dy * dy2;\n  var d1Sqr = cp1LenSqr - projLen1 * projLen1;\n  var d2Sqr = cp2LenSqr - projLen2 * projLen2;\n\n  if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {\n    out.push(x3, y3);\n    return;\n  }\n\n  var tmpSegX = [];\n  var tmpSegY = [];\n  cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);\n  cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);\n  adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out, scale);\n  adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out, scale);\n}\n\nexport function pathToPolygons(path, scale) {\n  var bezierArrayGroups = pathToBezierCurves(path);\n  var polygons = [];\n  scale = scale || 1;\n\n  for (var i = 0; i < bezierArrayGroups.length; i++) {\n    var beziers = bezierArrayGroups[i];\n    var polygon = [];\n    var x0 = beziers[0];\n    var y0 = beziers[1];\n    polygon.push(x0, y0);\n\n    for (var k = 2; k < beziers.length;) {\n      var x1 = beziers[k++];\n      var y1 = beziers[k++];\n      var x2 = beziers[k++];\n      var y2 = beziers[k++];\n      var x3 = beziers[k++];\n      var y3 = beziers[k++];\n      adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale);\n      x0 = x3;\n      y0 = y3;\n    }\n\n    polygons.push(polygon);\n  }\n\n  return polygons;\n}","map":null,"metadata":{},"sourceType":"module"}