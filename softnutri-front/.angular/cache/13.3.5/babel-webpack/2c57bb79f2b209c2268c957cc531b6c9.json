{"ast":null,"code":"import { trigger, state, style, transition, animate, keyframes } from '@angular/animations';\nimport * as i0 from '@angular/core';\nimport { Component, Input, ViewChild, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n/* eslint-disable no-restricted-properties */\n\n/** normalize\n * This lets us translate a value from one scale to another.\n *\n * @param value - Our initial value to translate\n * @param min - the current minimum value possible\n * @param max - the current maximum value possible\n * @param scaleMin - the min value of the scale we're translating to\n * @param scaleMax - the max value of the scale we're translating to\n * @returns the value on its new scale\n */\n\nconst _c0 = [\"pathEl\"];\n\nfunction TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"stop\");\n  }\n\n  if (rf & 2) {\n    const g_r4 = ctx.$implicit;\n    i0.ɵɵattribute(\"key\", g_r4.idx)(\"offset\", g_r4.offset)(\"stop-color\", g_r4.stopColor);\n  }\n}\n\nfunction TrendComponent__svg_svg_0__svg_defs_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"defs\")(1, \"linearGradient\", 3);\n    i0.ɵɵtemplate(2, TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template, 1, 3, \"stop\", 4);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"id\", ctx_r1.gradientId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.gradientTrimmed);\n  }\n}\n\nconst _c1 = function (a0, a1, a2) {\n  return {\n    autoDrawDuration: a0,\n    autoDrawEasing: a1,\n    lineLength: a2\n  };\n};\n\nconst _c2 = function (a0, a1) {\n  return {\n    value: a0,\n    params: a1\n  };\n};\n\nfunction TrendComponent__svg_svg_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"svg\");\n    i0.ɵɵtemplate(1, TrendComponent__svg_svg_0__svg_defs_1_Template, 3, 2, \"defs\", 0);\n    i0.ɵɵelement(2, \"path\", 1, 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"width\", ctx_r0.svgWidth)(\"height\", ctx_r0.svgHeight)(\"stroke\", ctx_r0.stroke)(\"stroke-width\", ctx_r0.strokeWidth)(\"stroke-linecap\", ctx_r0.strokeLinecap)(\"viewBox\", ctx_r0.viewBox)(\"preserveAspectRatio\", ctx_r0.preserveAspectRatio);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.gradient && ctx_r0.gradient.length);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"@pathAnimaiton\", i0.ɵɵpureFunction2(15, _c2, ctx_r0.animationState, i0.ɵɵpureFunction3(11, _c1, ctx_r0.autoDrawDuration, ctx_r0.autoDrawEasing, ctx_r0.lineLength)));\n    i0.ɵɵattribute(\"stroke\", ctx_r0.pathStroke)(\"d\", ctx_r0.d);\n  }\n}\n\nfunction normalize(value, min, max, scaleMin = 0, scaleMax = 1) {\n  // If the `min` and `max` are the same value, it means our dataset is flat.\n  // For now, let's assume that flat data should be aligned to the bottom.\n  if (min === max) {\n    return scaleMin;\n  }\n\n  return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);\n}\n/** moveTo\n * the coordinate that lies at a midpoint between 2 lines, based on the radius\n *\n * @param to - Our initial point\n * @param to.x - The x value of our initial point\n * @param to.y - The y value of our initial point\n * @param from - Our final point\n * @param from.x - The x value of our final point\n * @param from.y - The y value of our final point\n * @param radius - The distance away from the final point\n * @returns an object holding the x/y coordinates of the midpoint.\n */\n\n\nfunction moveTo(to, from, radius) {\n  const length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));\n  const unitVector = {\n    x: (to.x - from.x) / length,\n    y: (to.y - from.y) / length\n  };\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius\n  };\n}\n/** getDistanceBetween\n * Simple formula derived from pythagoras to calculate the distance between\n * 2 points on a plane.\n *\n * @param p1 - Our initial point\n * @param p1.x - The x value of our initial point\n * @param p1.y - The y value of our initial point\n * @param p2 - Our final point\n * @param p2.x - The x value of our final point\n * @param p2.y - The y value of our final point\n * @returns the distance between the points.\n */\n\n\nconst getDistanceBetween = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n/** checkForCollinearPoints\n * Figure out if the midpoint fits perfectly on a line between the two others.\n *\n * @param p1 - Our initial point\n * @param p1.x - The x value of our initial point\n * @param p1.y - The y value of our initial point\n * @param p2 - Our mid-point\n * @param p2.x - The x value of our mid-point\n * @param p2.y - The y value of our mid-point\n * @param p3 - Our final point\n * @param p3.x - The x value of our final point\n * @param p3.y - The y value of our final point\n * @returns whether or not p2 sits on the line between p1 and p3.\n */\n\n\nconst checkForCollinearPoints = (p1, p2, p3) => (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);\n\nconst buildLinearPath = data => data.reduce((path, point, index) => {\n  // The very first instruction needs to be a \"move\".\n  // The rest will be a \"line\".\n  const isFirstInstruction = index === 0;\n  const instruction = isFirstInstruction ? 'M' : 'L';\n  return `${path}${instruction} ${point.x},${point.y}\\n`;\n}, '');\n\nfunction buildSmoothPath(data, radius) {\n  const [firstPoint, ...otherPoints] = data;\n  return otherPoints.reduce((path, point, index) => {\n    const next = otherPoints[index + 1];\n    const prev = otherPoints[index - 1] || firstPoint;\n    const isCollinear = next && checkForCollinearPoints(prev, point, next);\n\n    if (!next || isCollinear) {\n      // The very last line in the sequence can just be a regular line.\n      return `${path}\\nL ${point.x},${point.y}`;\n    }\n\n    const distanceFromPrev = getDistanceBetween(prev, point);\n    const distanceFromNext = getDistanceBetween(next, point);\n    const threshold = Math.min(distanceFromPrev, distanceFromNext);\n    const isTooCloseForRadius = threshold / 2 < radius;\n    const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;\n    const before = moveTo(prev, point, radiusForPoint);\n    const after = moveTo(next, point, radiusForPoint);\n    return [path, `L ${before.x},${before.y}`, `S ${point.x},${point.y} ${after.x},${after.y}`].join('\\n');\n  }, `M ${firstPoint.x},${firstPoint.y}`);\n}\n\nconst generateId = () => Math.round(Math.random() * Math.pow(10, 16));\n\nfunction normalizeDataset(data, minX, maxX, minY, maxY) {\n  // For the X axis, we want to normalize it based on its index in the array.\n  // For the Y axis, we want to normalize it based on the element's value.\n  //\n  // X axis is easy: just evenly-space each item in the array.\n  // For the Y axis, we first need to find the min and max of our array,\n  // and then normalize those values between 0 and 1.\n  const boundariesX = {\n    min: 0,\n    max: data.length - 1\n  };\n  const boundariesY = {\n    min: Math.min(...data),\n    max: Math.max(...data)\n  };\n  const normalizedData = data.map((point, index) => ({\n    x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),\n    y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY)\n  })); // According to the SVG spec, paths with a height/width of `0` can't have\n  // linear gradients applied. This means that our lines are invisible when\n  // the dataset is flat (eg. [0, 0, 0, 0]).\n  //\n  // The hacky solution is to apply a very slight offset to the first point of\n  // the dataset. As ugly as it is, it's the best solution we can find (there\n  // are ways within the SVG spec of changing it, but not without causing\n  // breaking changes).\n\n  if (boundariesY.min === boundariesY.max) {\n    normalizedData[0].y += 0.0001;\n  }\n\n  return normalizedData;\n}\n\nlet TrendComponent = /*#__PURE__*/(() => {\n  class TrendComponent {\n    constructor() {\n      this.autoDraw = false;\n      this.autoDrawDuration = 2000;\n      this.autoDrawEasing = 'ease';\n      this.padding = 8;\n      this.radius = 10;\n      this.stroke = 'black';\n      this.strokeLinecap = '';\n      this.strokeWidth = 1;\n      this.gradient = [];\n      this.svgHeight = '25%';\n      this.svgWidth = '100%';\n      this.animationState = '';\n      this.id = generateId();\n      this.gradientId = `ngx-trend-vertical-gradient-${this.id}`;\n    }\n\n    ngOnChanges() {\n      // We need at least 2 points to draw a graph.\n      if (!this.data || this.data.length < 2) {\n        return;\n      } // `data` can either be an array of numbers:\n      // [1, 2, 3]\n      // or, an array of objects containing a value:\n      // [{ value: 1 }, { value: 2 }, { value: 3 }]\n      //\n      // For now, we're just going to convert the second form to the first.\n      // Later on, if/when we support tooltips, we may adjust.\n\n\n      const plainValues = this.data.map(point => {\n        if (typeof point === 'number') {\n          return point;\n        }\n\n        return point.value;\n      }); // Our viewbox needs to be in absolute units, so we'll default to 300x75\n      // Our SVG can be a %, though; this is what makes it scalable.\n      // By defaulting to percentages, the SVG will grow to fill its parent\n      // container, preserving a 1/4 aspect ratio.\n\n      const viewBoxWidth = this.width || 300;\n      const viewBoxHeight = this.height || 75;\n      this.svgWidth = this.width || '100%';\n      this.svgHeight = this.height || '25%';\n      this.viewBox = `0 0 ${viewBoxWidth} ${viewBoxHeight}`;\n      const root = location.href.split(location.hash || '#')[0];\n      this.pathStroke = this.gradient && this.gradient.length ? `url('${root}#${this.gradientId}')` : undefined;\n      this.gradientTrimmed = this.gradient.slice().reverse().map((val, idx) => {\n        return {\n          idx,\n          stopColor: val,\n          offset: normalize(idx, 0, this.gradient.length - 1 || 1)\n        };\n      });\n      const normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, // NOTE: Because SVGs are indexed from the top left, but most data is\n      // indexed from the bottom left, we're inverting the Y min/max.\n      viewBoxHeight - this.padding, this.padding);\n\n      if (this.autoDraw && this.animationState !== 'active') {\n        this.animationState = 'inactive';\n        setTimeout(() => {\n          this.lineLength = this.pathEl.nativeElement.getTotalLength();\n          this.animationState = 'active';\n        });\n      }\n\n      this.d = this.smooth ? buildSmoothPath(normalizedValues, this.radius) : buildLinearPath(normalizedValues);\n    }\n\n  }\n\n  TrendComponent.ɵfac = function TrendComponent_Factory(t) {\n    return new (t || TrendComponent)();\n  };\n\n  TrendComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TrendComponent,\n    selectors: [[\"ngx-trend\"]],\n    viewQuery: function TrendComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pathEl = _t.first);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      smooth: \"smooth\",\n      autoDraw: \"autoDraw\",\n      autoDrawDuration: \"autoDrawDuration\",\n      autoDrawEasing: \"autoDrawEasing\",\n      width: \"width\",\n      height: \"height\",\n      padding: \"padding\",\n      radius: \"radius\",\n      stroke: \"stroke\",\n      strokeLinecap: \"strokeLinecap\",\n      strokeWidth: \"strokeWidth\",\n      gradient: \"gradient\",\n      preserveAspectRatio: \"preserveAspectRatio\",\n      svgHeight: \"svgHeight\",\n      svgWidth: \"svgWidth\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"fill\", \"none\"], [\"pathEl\", \"\"], [\"x1\", \"0%\", \"y1\", \"0%\", \"x2\", \"0%\", \"y2\", \"100%\"], [4, \"ngFor\", \"ngForOf\"]],\n    template: function TrendComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, TrendComponent__svg_svg_0_Template, 4, 18, \"svg\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.data && ctx.data.length >= 2);\n      }\n    },\n    directives: [i1.NgIf, i1.NgForOf],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('pathAnimaiton', [state('inactive', style({\n        display: 'none'\n      })), transition('* => active', [style({\n        display: 'initial'\n      }), // We do the animation using the dash array/offset trick\n      // https://css-tricks.com/svg-line-animation-works/\n      animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([style({\n        'stroke-dasharray': '{{ lineLength }}px',\n        'stroke-dashoffset': '{{ lineLength }}px'\n      }), style({\n        'stroke-dasharray': '{{ lineLength }}px',\n        'stroke-dashoffset': 0\n      })])), // One unfortunate side-effect of the auto-draw is that the line is\n      // actually 1 big dash, the same length as the line itself. If the\n      // line length changes (eg. radius change, new data), that dash won't\n      // be the same length anymore. We can fix that by removing those\n      // properties once the auto-draw is completed.\n      style({\n        'stroke-dashoffset': '',\n        'stroke-dasharray': ''\n      })])])]\n    }\n  });\n  return TrendComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TrendModule = /*#__PURE__*/(() => {\n  class TrendModule {}\n\n  TrendModule.ɵfac = function TrendModule_Factory(t) {\n    return new (t || TrendModule)();\n  };\n\n  TrendModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TrendModule\n  });\n  TrendModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return TrendModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TrendComponent, TrendModule }; //# sourceMappingURL=ngx-trend.mjs.map","map":null,"metadata":{},"sourceType":"module"}